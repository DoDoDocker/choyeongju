# 섹션 8.  스토리지와 볼륨

# 컨테이너의 상태(State)

## ✅ 상태 없음 (Stateless)

### 📌 상태를 가진다?

- 프로그램 실행 중 변경된 데이터나 설정 등이 그대로 유지되는 것
- 배포/업데이트 시에 실행 중인 서버에 직접 들어가서 수동으로 패치해야 함 → 장애의 위험이 있음

### 📌 **컨테이너의 업데이트 방식**

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image.png)

- 컨테이너는 실행 후 발생하는 모든 변경 사항을 **컨테이너 레이어**에만 저장
    - 이 컨테이너가 삭제되면 해당 레이어(변경 사항)도 **모두 함께 사라짐**
    - 예를 들어 container2를 삭제하면, 이 컨테이너에 쌓인 모든 변경 내용도 완전히 없어진다.
- 컨테이너를 운영하는 도중 **이미지의 버전을 변경하려면**, 기존 컨테이너를 삭제하고 새로운 이미지로 다시 실행해야 한다.
    - 이름은 같더라도, 새로운 컨테이너에는 **기존 상태가 전혀 남지 않음!**
- 컨테이너는 **변경 사항이 누적되지 않고**, 항상 새로운 이미지로부터 시작한다.
- 컨테이너는 Stateless 하기 때문에 빠르고 쉽게 개수를 증가시킬 수 있다.

### 📌 **(ex) Nginx 버전 업그레이드**

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%201.png)

- 전통 방식: 가상머신에 직접 접속해 Nginx 1.21.1 → 1.23.2로 수동 업그레이드
- Docker 방식: 기존 Nginx 1.21.1 이미지를 폐기하고, 1.23.2 버전 이미지를 새로 빌드 및 배포

### 📌 **Stateless 의 장점**

- 복제/스케일링에 매우 용이
- 하나의 이미지로부터 → 여러 개의 컨테이너를 쉽게 만들어낼 수 있어 확장성 & 배포 속도 good
- 운영 환경이 자주 변경되어도, 이미지만 새로 만들면 언제 어디서나 재배포 가능

---

## ✅ PET & Cattle

> 클라우드 네이티브 구조에서 서버를 다루는 방법론
→ 서버를 바라보는 관점의 변화
> 

클라우드 네이티브 환경에서는 MSA 아키텍처를 기반으로 개발이 이루어짐

→ 이런 아키텍쳐 구조는 서버의 개수가 매우 많아지게 된다.

### **🐶 펫(Pet) 방식**

- 서버 한 대 한 대를 소중히 다룸
- 서버를 직접 SSH 등으로 관리
- 서버에 문제가 생기면 수작업으로 복구
- 서버 자체를 장기적으로 운영 및 주시

### **🐄 캐틀(Cattle) 방식**

- 서버를 일종의 소모품처럼 취급
- 서버가 죽어도 “큰 문제”가 아님 → 장애 복구로 커버 가능
- 서버는 상태를 가지지 않음 → Stateless
- 문제가 생기면 서버를 복구하는 대신, 빠르게 새 서버로 교체

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%202.png)

---

## ✅ 컨테이너의 Stateless 특징

### 📌 특징

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%203.png)

### 📌 주의할 점

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%204.png)

# 도커 볼륨(Docker Volume)

## ✅ 컨테이너의 영속성(Persistence)

### 📌 영속성

서버를 운영하다 보면 데이터를 지속적으로 유지해야할 경우가 생긴다.

*유지 : IT 환경에서는 ‘영속성이 있다’고 표현한다.

데이터베이스(DB) 컨테이너처럼 중요한 데이터를 다루는 경우,
컨테이너가 삭제되거나 재생성될 때마다 데이터가 초기화되면 운영에 어려움이 있을 것!

### 📌 서버 이중화

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%205.png)

- 운영 환경에서는 같은 역할을 하는 서버(컨테이너)를 여러 대 띄우는 것이 일반적
    - 한 대에 문제가 생겨도 다른 한 대가 동작을 이어받을 수 있도록
    - 트래픽 증가할수록 컨테이너 개수를 늘려서 대응 가능(스케일 아웃)

### 📌 데이터 불일치 문제

- 클라이언트의 요청은 로드밸런싱이라는 네트워크 처리를 거쳐서 데이터베이스 1, 2, 3 컨테이너들에게 랜덤하게 전달된다.
- (ex) A라는 상품의 가격을 여러 번 조회하는 경우
    - 로드밸런싱 되어서 여러개의 컨테이너에 상품 조회 요청이 분산
    - 1번 컨테이너에서 가진 데이터가 2, 3번 컨테이너와 다르다면 문제가 될 수 있다.

→ DB처럼 영속성이 필요한 데이터는 공유 저장소에 저장되어야 함!

### 📌 도커 볼륨의 필요성

→ 컨테이너는 상태가 없지만, 상태가 필요한 데이터는 외부 저장소에 저장해두는거지!

→ Docker Volume 사용

- 컨테너의 모든 데이터를 저장하는 건 아니고, 컨테이너의 특정 폴더를 공유용 폴더로 만들 수 있다.
    - 컨테이너의 폴더를 볼륨에 마운트 한다고 표현한다.
- 특정 컨테이너 내부 폴더를 외부 저장소(볼륨)에 마운트함
- 이 마운트된 경로에 저장된 데이터는 컨테이너 재시작/삭제 후에도 유지됨
- 여러 컨테이너가 같은 볼륨을 마운트하면 데이터를 공유할 수 있음

---

## ✅ 마운트 (Mount)

> 특정 디렉토리를 외부 저장소로 대체하는 것
⇒ 컴퓨터의 특정 디렉토리를 외부 저장소와 연결한다는 의미
> 

### 📌 비유..

- USB를 PC에 연결하면 새로운 드라이브가 만들어지고, 여기에 데이터 저장 및 공유 가능.
- 물리적인 장치를 → 시스템의 디렉토리에 연결하는 것 = 마운트

- NFS(Network File System)같은 네트워크 기반 저장소도 여러 대의 컴퓨터에서 동시에 마운트해서 사용할 수 있음.
    - 스토리지의 종류에 따라서 마운트 되는 단위 달라짐,

### 📌 예

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%206.png)

- Database 컨테이너 1, 2, 3이 /var/lib/postgresql/data 경로를 같은 Volume에 마운트
    - 이제부터 컨테이너가 실행된 다음에 경로에 저장하는 파일들은 컨테이너 레이어에 저장되는 것이 아니라, 마운트되어 있는 외부 볼륨에 저장됨
- 어떤 컨테이너에 요청이 가든, 공통된 Volume에 접근하므로 항상 동일한 데이터를 제공

---

## ✅ 도커 볼륨(Volume)

### 📌 Docker Volume ?

다시 정리해보자면..

- 도커 볼륨은 컨테이너의 데이터 영속성(Persistence) 을 보장하기 위한 기능이다.
- 컨테이너는 기본적으로 상태를 저장하지 않는(stateless) 특성을 가지므로, 재시작하거나 삭제하면 내부 데이터도 사라진다.
- 이를 방지하기 위해 도커 볼륨을 사용해 외부 저장소와 연결하여 데이터를 유지할 수 있다.
- 마치 USB를 꽂아 사용하는 것처럼 컨테이너 외부에 데이터를 저장할 수 있게 해준다.

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/ac8c74d4-9bf5-4b7e-8e64-e6efc455328d.png)

- docker run 명령에 `-v` 옵션을 주면, 도커의 볼륨을 컨테이너의 디렉터리로 마운트할 수 있다.
- 콜론(:)을 기준으로 왼쪽에는 도커 볼륨의 이름, 오른쪽은 마운트할 경로
    - PostgreSQL 컨테이너 내부의 /var/lib/postgresql/data 디렉토리를 외부 볼륨에 마운트하면, 그 경로에 저장된 데이터는 컨테이너가 아니라 외부에 저장된다.

### 📌 주의

- Windows에서 마운트 경로 설정 시 : 뒤의 경로는 슬래시 / 2개를 반드시 붙여야 한다.
- 슬래시 하나만 쓰면 C:처럼 인식돼 경로 해석 오류가 날 수 있다.
- `도커 볼륨 하나 == 한 개의 USB` 와 동일한 개념으로 생각하면 됨.

하나의 컨테이너에는 여러 개의 볼륨 마운트 가능. = 하나의 컴퓨터에 여러개의 유에스비 꽂을 수 있는거랑 똑같음

### 📌 하나의 컨테이너가 여러 볼륨 마운트 가능

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/54e63069-f0e1-46be-bc15-83489ca15ef8.png)

- DB 설정과 관련된 파일들은 volume1 에서 관리
- 실제 데이터와 관련된 파일들은 volume2 에 저장되고 관리

### 📌 여러 컨테이너가 하나의 볼륨을 공유할 수 있음

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/d22aea01-21e9-4459-a8d2-5ecfd08786b8.png)

- 여러 컨테이너에서 같은 경로(/var/lib/postgresql/data)에 같은 볼륨을 마운트하면, 동일한 데이터 공유 가능
- 어떤 컨테이너로 요청하든 같은 데이터를 제공

### 📌 도커 볼륨이 실제 저장되는 위치

> 볼륨은 **호스트 머신(OS)의 특정 디렉토리**에 실제로 저장된다.
> 

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%207.png)

```bash
docker run -v volume1:/usr/share/nginx/html
```

→ usr/share/nginx/html 경로에 저장되는 데이터는 호스트의 /volumes/volume1 에 기록된다.

- 그림 하단의 /volumes/volume1, /volumes/volume2 등은 Docker가 관리하는 실제 물리 저장 위치
- 컨테이너가 데이터를 저장한다고 해도, 실제로는 호스트 OS의 이 경로에 저장되고 있다는 것을 의미한다.

---

## ✅ Bind mounts

- 도커 볼륨을 마운트할 때는 일반적으로 도커 볼륨 이름을 사용하여 컨테이너 내부 경로와 연결
    
    (ex) -v volume1:/container/path
    
- But, 도커가 자동으로 관리하는 경로(/var/lib/docker/volumes/...)는 사용자가 직접 접근하거나 확인하기 HARD!
- Bind Mounts를 사용하면, 도커 볼륨 대신 호스트 OS의 디렉토리 경로를 직접 지정해서 마운트할 수 O

### 📌 예시

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%208.png)

```bash
-v /data/mypostgres:/var/lib/postgresql/data
```

- `-v` 옵션으로 왼쪽에 볼륨 이름이 아니라, 디렉터리 경로를 지정하면 Host OS 의 바인드 마운트 사용 가능
- 호스트의 /data/mypostgres 디렉토리를 컨테이너의 /var/lib/postgresql/data 경로에 마운트

### 📌 장점

- Bind Mount는 도커가 자동으로 관리하는 volumes와 달리, Host OS에서 파일을 직접 확인하고 조작 가능
- 별도의 볼륨을 만들지 않고, 이미 존재하는 디렉토리를 그대로 사용할 수 O
- 디버깅처럼 컨테이너 내부 데이터를 실시간으로 살펴보거나, 로그/설정 파일 등을 외부에서 직접 확인해야 하는 상황에서 유용!

---

## ✅ 도커 볼륨 관련 명령어

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%208%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%87%E1%85%A9%E1%86%AF%E1%84%85%E1%85%B2%E1%86%B7%201e92899bcdc38073aa8cf63c84ae50ea/image%209.png)

- 컨테이너에 마운트되어 있는 볼륨은 삭제 불가
    - 어떤 컨테이너에서도 사용되고 있지 않을 때만 삭제 가능